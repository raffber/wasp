Introduction
============

``wasp`` is a build tool and build scripts are written in python.


Installation
------------

Be sure to have python3 installed. It is the only dependency of ``wasp``.
Note that python2 is not going to work, ``wasp`` is not backwards
compatible with python2 and is probably never going to be.

Let's get gstarted: ``cd`` into the project directory::

    $ cd path/to/project/directory
    $ wget https://raw.githubusercontent.com/raffber/wasp/master/wasp

``wasp`` extracts itself once you execute it for the first time.
If you upgrade it to a new version, it will automatically upgrade itself.


Your first build script
-----------------------

Now, create your first build script, called ``build.py`` in the same directory::

    import wasp

    @wasp.build
    def build():
        print('hello, world!')

Now run::

    $ ./wasp build
    hello, world!

What you see here is ``wasp`` executing a **Command** called "build".
For the time being, this command just prints "hello, world!".

A command may specify **dependencies** which are commands to be executed
before this specific command. One command may consist of multiple
handler functions, such that you can split the work between mutliple
functions and scripts. You can also invent your own command names and dependencies::

    import wasp

    @wasp.command('run', depends='build')
    def run():
        print('Run my program here!')

Tasks
------

One can think of a build system as a set of ``Tasks`` which have inputs
 (called "sources") and outputs (called ``targets``).


Now, let's do something else, which is not at all useful but demonstrates how
``Tasks`` work::


    import wasp
    from wasp import shell, ctx, file

    @wasp.build
    def build():
        source = file('build.py')
        target = source.to_builddir()
        yield shell('cp {SRC} {TGT}', sources=source, targets=target)

The ``shell()`` function creates a ``Task``, which runs a command (in this case ``cp``) on the shell.

Nodes
-----

Sources and targets are represented as nodes.
Each task defines a set of input and output nodes (called sources and targets).
These nodes point to some data, which may be used by the tasks, thus, the nodes
define a data dependency between the tasks which is used internally by wasp to
parallelize the execution of tasks.

Each time a task is executed, it is recorded which "state" the data of all source
and target nodes is in. If the state of either source or target nodes has changed,
the task is rerun.

There are two different kinds of nodes that are worth mentioning:
 * ``FileNode``: Points to a file and captures its state by a checksum
    across its data. These nodes are implicitly generated by a path to a file.
 * ``SymbolicNode``: A node which contains data in the form of ``Argument``
    items. It is implicitly generated by strings starting with a colon, e.g. ':config'.
    These nodes are used to pass information between tasks, such as which compiler
    to use.

Of course, tools (see :ref:`tools`) may define arbitrary types of nodes.
However, usually, these two basic node types are sufficient.

.. _arguments:

Arguments
---------

While some information may defined while creating tasks, some information is only
known while executing tasks (see :ref:`lifecycle`).
This information is transfered between tasks as so called ``Argument`` objects.
These are just key-value-parirs, where the value must be a json serializable type
(refer to :ref:`utility_json`).

Tasks can ``use()`` arguments, which makes them accessible during task execution
time using the ``task.arguments`` field.
A task ``task1`` may also pass information to another task ``task2`` using the ``task.result`` field.
This dependency is defined by calling ``task2.use(task1)``.
All arguments in ``task1.result`` will be available in ``task2.arguments``.
``task.arguments`` as well as ``task.result`` are ``ArgumentCollection`` objects, which
are dict-like and use the argument name as key.


.. _lifecycle:

Lifecycle  of as Build Process
------------------------------

A build process may be roughly divided into the following stages:

 *  Import of all modules. All build scripts are python modules.
 *  Execution of ``@wasp.init`` registered functions.
 *  Sourcing of ``@wasp.options`` for creating command line options.
 *  Calling of all function registered with ``@wasp.handle_options``.
 *  Running all task handler functions (e.g. all functions handling the ``build`` command)
    These functions will typically lead a set of tasks to be executed.
 *  Execution of all tasks. Usually this is parallelize to reduce build times.
    While executing, all changes to node signatures are recorded.
 *  Last but not least, all results are saved, in particular the signatures of all nodes,
    such that ``wasp`` knows which tasks do not need to be rerun during the next execution.


Passing Arguments between Tasks
-------------------------------




Further Reading
---------------



