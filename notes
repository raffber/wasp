First refactor steps
====================

 * change abspath to realpath
 * remove all internal dependencies on context, except in main?! possible?!
 * look at cleaning again defer('clean', tasks...)?
 * better files package support, rename directory to fs and also add a few tasks (copy, remove whatever)


Todos
=======

 * absolutely always save cache, even if exceptions
 * unify quote style

Ideas
=========

 * automatic tool loading?!
 * task generators
 * argument to disable commands registred by tools

 * CWD of all commands should be TOPDIR!
 * make sure make_nodes correctly handles paths => how does it know from where it is called? => possibly everything relative to topdir?
 * waf lock


Challanges and Questions
=============================

 * dummy nodes => Node('id'), how is it invalidated?!
 * what happens if a task does not have any sources nor targets? always = True implicitly?!
 * Think about path handling (relative/abssolute, recursion, CWD of commands, ...)


Next Tasks
----------

 * design refactor steps
 * write unittests
 * document code
 * possibly rewrite some code that is ugly


Extensions
-----------

 * declarative (autoload build.{json,yml}, use json subset, if build.py exists as well it takes precedence)
 * templates (fetch using git from external repo, copy over, keep a template-readme.txt)
 * metadata (e.g. for package generation)
 * gui (tkinter)
 * bashcompletion


=================================


import wasp

wasp.require_version('0.1')
wasp.load('dlang', 'wasp-tools')

@wasp.init
def init(ctx):
    # add options...
    ctx.options += wasp.EnableOption('asdfasdf'..)
    
@wasp.depends('.d')
def compile_d_file(ctx, sources):
    target = ctx.builddir.join(sources, append='.o')
    task = wasp.tasks.DCompile(ctx, source=sources, target=target)
    return task

@wasp.depends('.d.o', type='program')
def link_d_files(ctx, sources, target):
    if target is None:
        target = ctx.projectname
    task = wasp.tasks.DLink(ctx, source=sources, target=ctx.builddir.join(target))
    return task

@wasp.configure
def configure(ctx):
    ctx.store['env'] = ctx.env

@wasp.build
def build(ctx):
    files = ctx.dir.source.find_all('*.d')
    objfiles = ctx.generate(files)
    executable = ctx.generate(objfiles, target='bloxr', type='program')
    ctx.run(executable)

#equivalent to @wasp.install
@wasp.command('install', require='build')
def install(ctx):
    task = wasp.tasks.Install(ctx, source=ctx.builddir.join('bloxr'), target=ctx.prefix.join('bloxr'))
    ctx.run(task)

class DCompile(wasp.Task):
    def __init__(self, ctx, source=[], target=[]):
        super(self, wasp.Task).__init__(ctx, source, target)

    def run(self, ctx):
        pass


wasp.exec(projectname='bloxr')






 ================================
