Next Task
==========

Current:
---------

Next
-----
 * automatically serialize/restore things in ctx.g if primitive or serializable
 * option remember?! how? -> retrieve option collection from cache
    and override it with actually set options
    ctx.options.group('asdf').remember(keys=[...])
    during load time, after context load, make merge_keep() with loaded options
 * implement command line option to set ctx.arguments tasks:
    -d key=value
    --define key=value
    => accept " " or [" ", " ", " "] => how to parse?!


 * test, test, test, test and write doc
 * port to windows
 * port to pypy

Bugs
=======

Lower Priorieties/Questions
============================
 * progress bar! -> extension?!
 * ShellTask: are arguments properly quoted?
 * somehow trigger find_npm() automatically?!
 * check this: is node refresh always parallelized?!
 * improve chaining support sth like nodejs.install('jsmin').find_exe('jsmin')
    -> automatically insert dependencies
    -> could be done with scope
        with nodejs.chain() as n:
            yield n.install('jsmin')
            yield n.find_exe('jsmin').produce(':jsmin')
        -> equates to: n.install('jsmin').produce(':asdf') and n.find_exe('jsmin').depends(':asdf')
    -> nodejs can: import from wasp.task import make_chain -> chain = make_chain(install, finde_exe)
    -> maybe chain can be generalized?
    -> register TaskCreator (i.e. function returning a task)
    -> chain() populates with all TaskCreators
    or:
    with chain() as c:
        c += task
        c += task
    yield c <=== simplest and best solution
    and:
    with depends(task) as d:
        d += task
        d += task
 * allow ctx.g('subdir')? such that variables can be scoped => ctx.g(__file__)
 * check if relto is honored all the time str(path) should return standardized
    reperesentation
 * finding stuff is annoying sometimes => allow people skip find and provide
    a default value for certain arguments
    -> it should be possible to allow default
 * create a boolean node.... as in run_if(fun, task) -> TriggerNode
 * improve error output, somehow identify task if MissingArgumentError
 * remove the number of pitfalls
    -> collect them
    -> fix them
 * task.parallel must exist (e.g. for invoking external pkg managers)
 * in case of invalid json, ALWAYS raise ValueError! => replace assert with parse_assert
 * sync on log => no ugly race conditions in output
    --> with self.log: ...
 * better --help formatting: actually show descriptions
 * tidy up imports
 * refactor realpath to abspath
 * set default verbosity to info?!
 * what is --verror used for?
 * binary json?! maybe implmented by myself?
 * yaml subset which can be translated to json (a.k.a yson)
 * invocation from recursive directory: how to deduce topdir?!
 * simplify global bashcompletion activation
 * verbosity per decorator (use command class, assign all tasks their logger just after calling a command)
 * argumentprovider => register, such that retireve(asdf) works automatically by dispatching. => singledispatch?
 * util.Namespace class => inherit metadata, decoratorstore from it
 * escape : in filename (.replace('\:', ':') at str[0:1])
 * proper subproject handling (implemented as plugin to the recursion algorithm)
 * some way to make commands run again if specified implict as a dependency for another command and the former has already
   completed successfully. Use case might be an updated git repo which gets pulled in by "./wasp fetch" and should be updated
   regularly. => ctx.commands['configure'].invalidate(): REQUIRES: improved command api
 * could we integrate pip, easy_install? just install extensions as eggs? => test for import pip
   - if sth. is missing (e.g. templates, make it automatically installable)
   - install it to wasp temporary directory
   - if globally installed create wasp temporary directory
   - pip install --install-option="--prefix=$PREFIX_PATH" package_name
 * find a way to name arguments using the symbolic node name
    -> namespace the arguments
 * benchmark --> make things faster

Argument Refactor
==================

=> remove nested ArgumentCollections?! --> yes, pass information with ctx.g.asdf = asdf
    -> evaluation order of handlers should be clearly defined
    -> evaluate handler by order of import
=> overrides: task.overrides.append(provider)
=> ArgumentProviderBase
    -> defines __getitem__ and __setitem__
=> ArgumentProvider(ArgumentProviderBase)
    -> .limit(keys) limits the keys available
    -> provider(..., keys=[]) creates an argumentprovider and limits with keys
=> what about not overriding arguments by default?!
    -> maybe don't override arg if already there? (in check())


Global Installation and call from subdirectory
==============================================

note, that at the moment global installation of wasp is not possible
The implementation of this ``feature`` does not have particular priority, since
it is not the intended design of wasp. Though it might be useful for performance enhancement.

 * make sure local install has precedence over global install
 * subfiles must know the the topdir
 * with each command, save its origin with inspect.<whatever>()
 * if invoked in a subdir, only execute the commands in there
 * determining topdir: travel up in the path until:
    -> a .wasptop is found
    -> create .wasptop file automatically
    -> either gitignore or check-in

Pitfalls
========

 * better communicate if you forget to add a task
    i.e. if a task is used() but never added, this should somehow be detected
 * possibly make a pitfalls handler where information is collected

NPM Extension
--------------

 * make sure there is a way to tap into npm
 * probably also maven...
 * ... and pip
 * and cargo
 => how to support out of tree builds? maybe just don't?


subproject Extension
------------------

 * think about plugin api such that possible, what kind of hooks are required?
 * automatically add options for activating subprojects
 * wasp.subproject.activate.only('doc') or wasp.subproject.activate.except('doc')
 * same with deactivate
 * options --<subprojname> and --no-<subprojname> --all --none

Extensions
-----------

 * templates (fetch using git from external repo, copy over, keep a template-readme.txt)
    - register a command init-template
 * gui (tkinter)
    - run commands
    - edit arguments => use a visitor for option types and support single dispatch to extend
    - display depenency tree?!
 * think about background daemons (daemon autostart extension?!) Daemon('adsf').ensure_running().produce(':daemon')
    --> openocd
    --> gdb server


Removal of global variables
===========================

 * see if this is an issue -> if yes, implement this in a separate branch
    -> probably not going to happen, since most likely, this is a non-issue
 * possibly use some dependency injection algorithm
    -> default argument could be   def whatever(ctx=inject('ctx')): ....
 * inject a context into the loaded modules?
 * provide a set of clever macros which allows capturing context
 * make a default context global?! retrieve ctx automatically if not provided
 * pass the context everywhere
 * port signature stuff into context again
 * allow passing ctx to the fs components
 * how to handle decorators?!
    --> couple the decorator to a context with module imports
    --> this can be accomplished by locking on a global object
    --> create_context() may create a new context based on an old one.

Ideas for more features
=======================

 * create an internal package manager similiar to pip, npm or maven
 * create a declarative interface, reducing build.py to sth like wasp.from_json('build.json')
 * create an extension api and allow fetching extensions with the package manager
 * integrate the build system with vcs-tools such as git (providing hooks)
 * create an extension for code checkers
 * allow outputting projects for IDEs
 * create a flask web app for managing unittests and more
 * create a curses-gui for project configuration (sth like kconfig of linux kernel??)
 * create an extension for deployment tasks (e.g. directly deploy a web app to the server)
