Random thoughts
-----------------------
 * make sure thread safety is ensured if symbolic nodes are written, i.e. write them upon completion, result is just argument collection
 * properly implement decorators!!
 * does it really make sense to have prefix in context? i think this should just be a random argument

Next Task
==========
 * refactor environment: environment can be stored using a argumentcollection => argumentcollection.overwrite(environ)
 * make environment inherit from argumentcollection? just read only?
 * implement all NotImplentedError raises
 * cache usage: always give cache object as argument in load() and save()
 * execution engine

Todos
=======
 * ABSOLUTELY make sure ctx is only reachable from main thread
 * escape : in filename (.replace('\:', ':') at str[0:1])
 * automatically add deferred commands
 * ArgumentCollection can contain ArgumentCollection => WHY? SRSLY?
 * dependencies (command internal using nodes, command external? just using required arguments?)
 * proper subproject handling (implemented as plugin to the recursion algorithm)
 * wasp specific commands and options:
    - outsource into own module
    - postprocess step options decorator
    - clear cache: clear-cache
    - verbosity
 * some way to make commands run again if specified implict as a dependency for another command and the former has already
   completed successfully. Use case might be an updated git repo which gets pulled in by "./wasp fetch"
 * do not allow context access within task execution! overwrite ctx with a lock proxy.
 * refactor signature identifier to key: generally, refactor all "identifier" to "key"

Implement before initial API stability
=======================================
 * enable building only a specific target with: ./wasp <command> --target :whatever
 * allow people to name the build file either BUILD or build.py or just build?!
 * ArgumentCollection.load('asdf.json') to load an ArgumentCollection from a file
 * recursion

Refactor steps
==============


Dependency management
======================

New
-----

 * we might need to use ".use()" for dependencies between commands
    hopefully this can be avoided. E.g. by saying that if there is no
    task producing a given node, the already produced node is used.
    that would acutally be similiar to a filenode.

class DependencyCheck(Task): contains dependency

glib = cpp.check('glib').produce(':glib')
myexec = cpp.compile('main.c').depends(':glib')

Old
-----

class DependencyCheck(Task): contains dependency

class Dependency(ArgumentCollection): contains arguments, serializable

glib = cpp.check('glib')
myexec = cpp.compile()
myexec.depends(glib)

 * depends function is inherited from task, which just adds a task dependency
 * is overrided to insert the required arguments
 * ctx.dependencies collects dependencies, dependency check task adds itself uppon success
 * myexec.use(ctx.dependencies['glib']) for using a previously saved dependency


Recursion
=========

 * use topdir = '../' *3 for subprojects
 * have currentdir, current_builddir in context
 * variables from higher-level directories can be overwritten
 * @recurse for recurse, can be applied to a varianle declaration? recurse should otherwise be called during init
 * add executiondir to ctx, so one can check if executiondir == currentdir

subproject plugin
------------------

 * think about plugin api such that possible, what kind of hooks are required?
 * automatically add options for activating subprojects
 * wasp.subproject.activate.only('doc') or wasp.subproject.activate.except('doc')
 * same with deactivate
 * options --<subprojname> and --no-<subprojname> --all --none

Generators
===========

 * create a generator() task
 * while building, run generators for the targets that are created
 * add command_name='clean' to filter for command name
 * add tags='asdf', then wasp.generator(tags='asfd') can be run. => generator must include tag
 * add a collect attribute, meaning all tasks are run before the generator is run. The generator is then invoked
   with **all** sources.

Declarative
============

 * declarative tag handlers => register with factory
 * use yaml or json as markup - yaml has dependency ;(
 * run in init handler wasp.run_declarative('build.yml', format=None) infers format with 'json' => json, 'yml' => yaml


'options' : {
    'optimization' : ['debug', 'release']
}

'argument' : {
    'CFLAGS' : {
        ....
    }
}

'commands' : {
    'build' : {
        'files' : '*.c',
        'tool' : 'cpp',
        'command' : 'compile',
        'clean' : false,
        'use' : {
            'CFLAGS' : [
                    {
                        'argument' : 'CFLAGS'
                    },
                    {
                        'switch' : 'optimization',
                        'results' : {
                            'debug' : '-g -O0',
                            'release' : '-g -O0'
                    },
                    '--shared'
                ],
            }
        }
    }
}

Wasp Tools
==========

invocation ./wasp tool <toolname>

e.g.
./wasp tool daemon


Ideas
=========

 * automatic tool loading?!
 * task generators
 * argument to disable commands registred by tools

 * CWD of all commands should be TOPDIR!
 * make sure make_nodes correctly handles paths => how does it know from where it is called? => possibly everything relative to topdir?
 * waf lock
 * daemon: simply use generator functions. also make an @changed(extension) available


Challanges and Questions
=============================

 * dummy nodes => Node('id'), how is it invalidated?!
 * what happens if a task does not have any sources nor targets? always = True implicitly?!
 * could we integrate pip, easy_install?

Next Tasks
----------

 * design refactor steps
 * write unittests
 * document code
 * possibly rewrite some code that is ugly


Extensions
-----------

 * templates (fetch using git from external repo, copy over, keep a template-readme.txt)
 * metadata (e.g. for package generation) => use metadata.{json, yml} => wasp.use_metadata('metadata.json', format=...)
 * gui (tkinter)
 * bashcompletion


=================================


import wasp

wasp.require_version('0.1')
wasp.load('dlang', 'wasp-tools')

@wasp.init
def init(ctx):
    # add options...
    ctx.options += wasp.EnableOption('asdfasdf'..)
    
@wasp.depends('.d')
def compile_d_file(ctx, sources):
    target = ctx.builddir.join(sources, append='.o')
    task = wasp.tasks.DCompile(ctx, source=sources, target=target)
    return task

@wasp.depends('.d.o', type='program')
def link_d_files(ctx, sources, target):
    if target is None:
        target = ctx.projectname
    task = wasp.tasks.DLink(ctx, source=sources, target=ctx.builddir.join(target))
    return task

@wasp.configure
def configure(ctx):
    ctx.store['env'] = ctx.env

@wasp.build
def build(ctx):
    files = ctx.dir.source.find_all('*.d')
    objfiles = ctx.generate(files)
    executable = ctx.generate(objfiles, target='bloxr', type='program')
    ctx.run(executable)

#equivalent to @wasp.install
@wasp.command('install', require='build')
def install(ctx):
    task = wasp.tasks.Install(ctx, source=ctx.builddir.join('bloxr'), target=ctx.prefix.join('bloxr'))
    ctx.run(task)

class DCompile(wasp.Task):
    def __init__(self, ctx, source=[], target=[]):
        super(self, wasp.Task).__init__(ctx, source, target)

    def run(self, ctx):
        pass


@wasp.generate('*.o')
def link(files):
    return cpp.link(files)

@wasp.generate(['c', 'cpp'], command='clean')
def compile(files):
    return cpp.compile(files)





 ================================
