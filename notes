Next Task
==========

 * option parsing
 * extension api
 * finish d tool with find task => see what can be imported into core
 * execution: limit production to a list of nodes given by produce in DAG
 * test, test, test, test and write doc

Option Parsing
===============

 * bashcompletion (test if argcomplete is installed, if yes, use it)

Extensions
===========
=> think about what they should be able to do
   - report state of DAG => implement wasp.ext.progress
   - make sure DAG can be inherited s.t. it can be used without executing tasks (simulate their execution) => wasp.ext.ninja
   - execution_started(tasks)
   - task_started(task)
   - task_finished(task)
   - preprocess_tasks(tasks)
   - execution_finished(tasks)
   - context_created()
   - initialized()
   - options_parsed()
   - command_execution_started()
   - command_execution_finished()
   - tasks_loaded(tasks)

TODOs
========

 * think about background daemons (daemon autostart extension?!) Daemon('adsf').ensure_running().produce(':daemon')
 * think about: does use() implies depends? in the case of nodes and tasks


Bugs
=======

 * in case of invalid json, ALWAYS raise ValueError! => replace assert with parse_assert
 * md is run always?!
 * properly handle exceptions occuring in a task

----->8--------

./wasp --vdebug rebuild build
Config file at ./wasprc.user.json does not exist.
[SUCC]  Command: `clean`
[SUCC]  /usr/bin/dmd  -c /home/raff/raffbuild/two.d -of/home/raff/raffbuild/build/two.d.o
[SUCC]  /usr/bin/dmd  -c /home/raff/raffbuild/one.d -of/home/raff/raffbuild/build/one.d.o
[SUCC]  cp -r /home/raff/raffbuild/notes /home/raff/raffbuild/build/notes
[SUCC]  /usr/bin/dmd  /home/raff/raffbuild/build/one.d.o /home/raff/raffbuild/build/two.d.o -of/home/raff/raffbuild/build/main
[SUCC]  Command: `build`
[SUCC]  Command: `rebuild`
[SUCC]  /usr/bin/dmd  -c /home/raff/raffbuild/one.d -of/home/raff/raffbuild/build/one.d.o
[SUCC]  /usr/bin/dmd  /home/raff/raffbuild/build/one.d.o /home/raff/raffbuild/build/two.d.o -of/home/raff/raffbuild/build/main
[SUCC]  Command: `build`

----------8<---------

Lower Priorieties
===================

 * improve keyboard handling of interrupts during execution
 * verbosity per decorator (use command class, assign all tasks their logger just after calling a command)
 * argumentprovider => register, such that retireve(asdf) works automatically by dispatching. => singledispatch?
 * util.Namespace class for decorator => inherit metadata, decoratorstore from it
 * improve ctx.commands API
 * optimize execution, detect if task is a noop => check all lists empty, and look if _run overridden
 * make sure thread safety is ensured if symbolic nodes are written, i.e. write them upon completion, result is just argument collection
 * escape : in filename (.replace('\:', ':') at str[0:1])
 * proper subproject handling (implemented as plugin to the recursion algorithm)
 * some way to make commands run again if specified implict as a dependency for another command and the former has already
   completed successfully. Use case might be an updated git repo which gets pulled in by "./wasp fetch" and should be updated
   regularly. => ctx.commands['configure'].invalidate()
 * refactor signature identifier to key: generally, refactor all "identifier" to "key"
 * could we integrate pip, easy_install? just install extensions as eggs? => test for import pip
   - if sth. is missing (e.g. templates, make it automatically installable)
   - install it to wasp temporary directory
   - if globally installed create wasp temporary directory
   - pip install --install-option="--prefix=$PREFIX_PATH" package_name


Global Installation and call from subdirectory
==============================================


# TODO: note, that at the moment global installation of wasp is not possible
        The implementation of this ``feature`` does not have particular priority, since
        it is not the intended design of wasp. Though it might be useful for performance enhancement.

 * make sure local install has precedence over global install
 * subfiles must know the the topdir
 * with each command, save its origin with inspect.<whatever>()
 * if invoked in a subdir, only execute the commands in there


subproject Extension
------------------

 * think about plugin api such that possible, what kind of hooks are required?
 * automatically add options for activating subprojects
 * wasp.subproject.activate.only('doc') or wasp.subproject.activate.except('doc')
 * same with deactivate
 * options --<subprojname> and --no-<subprojname> --all --none

Extensions
-----------

 * templates (fetch using git from external repo, copy over, keep a template-readme.txt)
    - register a command init-template
 * gui (tkinter)
    - run commands
    - edit arguments => use a visitor for option types and support single dispatch to extend
    - display depenency tree?!


Declarative
============

 * declarative tag handlers => register with factory
 * use yaml or json as markup - yaml has dependency ;(
 * run in init handler wasp.run_declarative('build.yml', format=None) infers format with 'json' => json, 'yml' => yaml


'options' : {
    'optimization' : ['debug', 'release']
}

'argument' : {
    'CFLAGS' : {
        ....
    }
}

'commands' : {
    'build' : {
        'files' : '*.c',
        'tool' : 'cpp',
        'command' : 'compile',
        'clean' : false,
        'use' : {
            'CFLAGS' : [
                    {
                        'argument' : 'CFLAGS'
                    },
                    {
                        'switch' : 'optimization',
                        'results' : {
                            'debug' : '-g -O0',
                            'release' : '-g -O0'
                    },
                    '--shared'
                ],
            }
        }
    }
}
